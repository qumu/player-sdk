{"version":3,"file":"index.modern.mjs","sources":["../src/lib/functions/functions.ts","../src/lib/callbacks/callbacks.ts","../src/services/player-sdk.service.ts"],"sourcesContent":["/**\n * Parses a message received from postMessage.\n *\n * @param data The data received from postMessage.\n */\nexport function parseMessageData<T>(data: string | T): T {\n  if (typeof data === 'string') {\n    try {\n      // eslint-disable-next-line no-param-reassign\n      data = JSON.parse(data);\n    } catch (error) {\n      return {} as T;\n    }\n  }\n\n  return data as T;\n}\n","export type FunctionOrPromise = Function | { reject: Function; resolve: Function };\n\nexport class CallbackStore {\n  private readonly map = new Map();\n\n  /**\n   * Gets all the callbacks for a specific event name\n   *\n   * @param name the event name we want the callbacks from\n   */\n  getCallbacks(name: string): Function[] | FunctionOrPromise[] {\n    return this.map.get(name) || [];\n  }\n\n  /**\n   * Removes the given callback for the event\n   *\n   * @param name the event name we want the callbacks from\n   * @param callback the callback to remove. If empty, it will remove all callbacks\n   */\n  removeCallback(name: string, callback?: FunctionOrPromise): void {\n    const callbacks = this.map.get(name) || [];\n\n    if (!callbacks) {\n      return;\n    }\n\n    // If no callback is passed, remove all callbacks for the event\n    if (!callback) {\n      this.map.delete(name);\n\n      return;\n    }\n\n    const index = callbacks.indexOf(callback);\n\n    if (index !== -1) {\n      callbacks.splice(index, 1);\n    }\n\n    if (callbacks.length === 0) {\n      this.map.delete(name);\n    } else {\n      this.map.set(name, callbacks);\n    }\n  }\n\n  /**\n   * Removes and return the first callback for the name\n   *\n   * @param name the event name we want the callbacks from\n   */\n  shiftCallback(name: string): FunctionOrPromise | undefined {\n    const callbacks = this.getCallbacks(name);\n\n    if (callbacks.length === 0) {\n      return undefined;\n    }\n\n    const callback = callbacks.shift();\n\n    this.removeCallback(name, callback);\n\n    return callback;\n  }\n\n  /**\n   * Stores the callback for the event\n   *\n   * @param name the event name we want the callbacks from\n   * @param callback the callback to store\n   */\n  storeCallback(name: string, callback: FunctionOrPromise): void {\n    const callbacks = this.map.get(name) || [];\n\n    callbacks.push(callback);\n\n    this.map.set(name, callbacks);\n  }\n}\n","import { parseMessageData } from '../lib/functions/functions';\nimport {\n  SdkCommandMessage,\n  SdkEventMessage,\n  SdkGetSetMessage,\n  SdkHandshakeMessage,\n  SdkMessage,\n} from '../models/internal';\nimport { CallbackStore, FunctionOrPromise } from '../lib/callbacks/callbacks';\nimport { SdkCaptionTrack, SdkLayout, SdkPipPosition, SdkPrimaryContent } from '../models/external';\n\nexport class PlayerSdk {\n  // store used for the callbacks\n  private readonly callbackStore: CallbackStore;\n\n  // Random guid used during Cross window communication\n  // This is useful to prevent communication bleeding between SDKs if the same presentation is used multiple times in the page\n  private readonly guid: string;\n\n  // callback for the message event listener once the handshake is done\n  private messageHandler: ((event: MessageEvent) => void) | undefined;\n\n  // origin url of the iframe's src\n  // we will use it to compare with the event's origin and filter out messages from unknown origins\n  private readonly originUrl: string;\n\n  // origin used to send cross window communication messages\n  // this is useful to target a specific origin and not have to broadcast to everybody\n  private origin = '*';\n\n  private readonly readyPromise: Promise<void>;\n\n  // Cross window communication format version\n  private readonly version = 3;\n\n  constructor(\n    private readonly iframe: HTMLIFrameElement,\n  ) {\n    this.originUrl = new URL(this.iframe.src).origin;\n    this.guid = crypto.randomUUID();\n\n    this.callbackStore = new CallbackStore();\n\n    // create the promise that will be used to verify if the messages can be exchanged with the player\n    this.readyPromise = new Promise((resolve) => {\n      this.messageHandler = (event: MessageEvent) => {\n        // ignore messages coming from another iframe\n        if (event.origin !== this.originUrl) {\n          return;\n        }\n\n        const message = parseMessageData<SdkMessage>(event.data);\n\n        // ignore messages from previous SDKs\n        if (message?.version !== this.version) {\n          return;\n        }\n\n        // ignores handshake from other SDKs\n        if (message?.action === 'handshake' && message?.guid !== this.guid) {\n          return;\n        }\n\n        if (message?.action === 'ready' || message?.action === 'handshake') {\n          // we provide the proper origin\n          // this allows us to send the cross window message to the proper origin and not broadcast to everybody\n          this.origin = event.origin;\n          resolve();\n\n          return;\n        }\n\n        this.processData(message);\n      };\n\n      window.addEventListener('message', this.messageHandler);\n    });\n\n    // we send a request for a handshake\n    // this one is useful in the event when the SDK is initialized after the player\n    this.postMessage({\n      action: 'handshake',\n      guid: this.guid,\n    } as SdkHandshakeMessage);\n  }\n\n  /**\n   * Registers a callback to be run when the event is triggered\n   *\n   * @param name the event name to listen to\n   * @param callback the callback to run when the event is triggered\n   */\n  addEventListener(name: SdkEventMessage['name'], callback: Function): void {\n    if (!name) {\n      throw new TypeError('You must pass an event name.');\n    }\n\n    if (!callback) {\n      throw new TypeError('You must pass a callback function.');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('The callback must be a function.');\n    }\n\n    const callbacks = this.callbackStore.getCallbacks(`event:${name}`);\n\n    // This is the first time we subscribe to this event, we need to tell the Player to start a watcher\n    if (callbacks.length === 0) {\n      this.readyPromise.then(() => {\n        this.postMessage({\n          action: 'event',\n          guid: this.guid,\n          name,\n          value: 'add',\n        } as SdkEventMessage);\n      });\n    }\n\n    this.callbackStore.storeCallback(`event:${name}`, callback);\n  }\n\n  /**\n   * Destroys the whole SDK\n   */\n  destroy(): void {\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n    }\n\n    this.postMessage({\n      action: 'command',\n      guid: this.guid,\n      name: 'destroy',\n    } as SdkCommandMessage);\n  }\n\n  /**\n   * Disables any caption track\n   */\n  disableCaptionTrack(): void {\n    this.enableCaptionTrack(null);\n  }\n\n  /**\n   * Sets the current caption track\n   *\n   * @param lang the language of the active track. Use null to disable captions.\n   */\n  enableCaptionTrack(lang: string | null): void {\n    this.set('captionTrack', lang);\n  }\n\n  /**\n   * Gets the available caption tracks\n   */\n  async getCaptionTracks(): Promise<SdkCaptionTrack[]> {\n    return this.get('captionTracks');\n  }\n\n  /**\n   * Gets the chapter\n   */\n  async getChapter(): Promise<any> {\n    return this.get('chapter');\n  }\n\n  /**\n   * Gets the list of chapters for the presentation\n   */\n  async getChapters(): Promise<any[]> {\n    return this.get('chapters');\n  }\n\n  /**\n   * Gets the current caption track\n   */\n  async getCurrentCaptionTrack(): Promise<SdkCaptionTrack | null> {\n    return this.get('captionTrack');\n  }\n\n  /**\n   * Gets the current time in milliseconds\n   */\n  async getCurrentTime(): Promise<number> {\n    return this.get('currentTime');\n  }\n\n  /**\n   * Gets the presentation's duration in milliseconds\n   */\n  async getDuration(): Promise<number> {\n    return this.get('duration');\n  }\n\n  /**\n   * Gets the layout\n   */\n  async getLayout(): Promise<SdkLayout> {\n    return this.get('layout');\n  }\n\n  /**\n   * Gets the presentation's duration in milliseconds\n   */\n  async getLiveEndTime(): Promise<string | null> {\n    return this.get('liveEndTime');\n  }\n\n  /**\n   * Gets the presentation's duration in milliseconds\n   */\n  async getLiveStartTime(): Promise<string | null> {\n    return this.get('liveStartTime');\n  }\n\n  /**\n   * Gets the presentation's live state\n   */\n  async getLiveState(): Promise<string | null> {\n    return this.get('liveState');\n  }\n\n  /**\n   * Gets the position of the PiP box\n   */\n  async getPictureInPicturePosition(): Promise<number> {\n    return this.get('pipPosition');\n  }\n\n  /**\n   * Gets the current playback rate\n   */\n  async getPlaybackRate(): Promise<number> {\n    return this.get('playbackRate');\n  }\n\n  /**\n   * Gets the list of playback rates\n   */\n  async getPlaybackRates(): Promise<number[]> {\n    return this.get('playbackRates');\n  }\n\n  /**\n   * Gets the presentation\n   */\n  async getPresentation(): Promise<any> {\n    return this.get('presentation');\n  }\n\n  /**\n   * Gets the primary content\n   */\n  async getPrimaryContent(): Promise<SdkPrimaryContent> {\n    return this.get('primaryContent');\n  }\n\n  /**\n   * Gets the side by side ratio between 50% and 80%\n   */\n  async getSideBySideRatio(): Promise<number> {\n    return this.get('sideBySideRatio');\n  }\n\n  /**\n   * Gets the player's volume between 0 and 100\n   */\n  async getVolume(): Promise<number> {\n    return this.get('volume');\n  }\n\n  /**\n   * Checks whether the player is paused or playing\n   */\n  async isPaused(): Promise<boolean> {\n    return this.get('paused');\n  }\n\n  /**\n   * Pauses the player\n   */\n  pause(): void {\n    this.command('pause');\n  }\n\n  /**\n   * Plays the player\n   */\n  play(): void {\n    this.command('play');\n  }\n\n  /**\n   * Stops listening to a player event\n   *\n   * @param name the event name to listen to\n   * @param callback the callback to remove. If no callback is provided, all callbacks will be removed for the event name\n   */\n  removeEventListener(name: string, callback?: Function): void {\n    if (!name) {\n      throw new TypeError('You must pass an event name.');\n    }\n\n    this.callbackStore.removeCallback(`event:${name}`, callback);\n\n    const callbacks = this.callbackStore.getCallbacks(`event:${name}`);\n\n    // Remove the watcher on the player's side if there are no subscribers for this event\n    if (callbacks.length === 0) {\n      this.postMessage({\n        action: 'event',\n        guid: this.guid,\n        name,\n        value: 'remove',\n      } as SdkEventMessage);\n    }\n  }\n\n  /**\n   * Sets the current time in the player\n   *\n   * @param time the new current time in milliseconds\n   */\n  setCurrentTime(time: number): void {\n    if (time < 0) {\n      throw new Error('The current time must be superior or equal to 0');\n    }\n\n    this.set('currentTime', time);\n  }\n\n  /**\n   * Sets the layout\n   *\n   * @param layout the new layout, either 'pip' or 'sbs'\n   */\n  setLayout(layout: SdkLayout): void {\n    this.set('layout', layout);\n  }\n\n  /**\n   * Sets the position of the PiP box\n   *\n   * @param position the PiP position\n   */\n  setPictureInPicturePosition(position: SdkPipPosition): void {\n    this.set('pipPosition', position);\n  }\n\n  /**\n   * Sets the playback rate in the player. The value must be between 0 and 2.\n   *\n   * @param playbackRate the new playback rate\n   */\n  setPlaybackRate(playbackRate: number): void {\n    if (playbackRate < 0) {\n      throw new Error('The playback rate must be superior or equal to 0');\n    }\n\n    if (playbackRate > 2) {\n      throw new Error('The playback rate must be inferior or equal to 2');\n    }\n\n    this.set('playbackRate', playbackRate);\n  }\n\n  /**\n   * Sets the primary content\n   *\n   * @param primaryContent the primary content\n   */\n  setPrimaryContent(primaryContent: SdkPrimaryContent): void {\n    this.set('primaryContent', primaryContent);\n  }\n\n  /**\n   * Sets the ratio for the Side by Side mode\n   *\n   * @param ratio the new ratio. The range is 50-80.\n   */\n  setSideBySideRatio(ratio: number): void {\n    if (ratio < 50 || ratio > 80) {\n      throw new Error('The ratio must be between 50 and 80');\n    }\n\n    this.set('sideBySideRatio', ratio);\n  }\n\n  /**\n   * Sets the volume in the player\n   *\n   * @param volume the new volume. The range is 0-100.\n   */\n  setVolume(volume: number): void {\n    if (volume < 0 || volume > 100) {\n      throw new Error('The volume must be between 0 and 100');\n    }\n\n    this.set('volume', volume);\n  }\n\n  /**\n   * Sends a COMMAND message to the iframe\n   *\n   * @param name the event name to send\n   * @param args optional arguments to send\n   * @private\n   */\n  private command(name: SdkCommandMessage['name'], args?: any): void {\n    const message: Omit<SdkCommandMessage, 'version'> = {\n      action: 'command',\n      guid: this.guid,\n      name,\n    };\n\n    if (args) {\n      message.value = args;\n    }\n\n    this.postMessage(message);\n  }\n\n  /**\n   * Sends a GET message to the iframe\n   *\n   * @param name the event name to send\n   * @private\n   */\n  private get<T>(name: SdkGetSetMessage['name']): Promise<T> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await this.readyPromise;\n\n        this.callbackStore.storeCallback(`get:${name}`, {\n          reject,\n          resolve,\n        });\n\n        this.postMessage({\n          action: 'get',\n          guid: this.guid,\n          name,\n        } as SdkGetSetMessage);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Sends a message to the iframe\n   *\n   * @param message the message to send\n   * @private\n   */\n  private postMessage(message: Omit<SdkMessage, 'version'>): void {\n    const messageString = JSON.stringify({\n      ...message,\n      version: this.version,\n    });\n\n    this.iframe.contentWindow?.postMessage(messageString, this.origin);\n  }\n\n  /**\n   * Processes the data from the message handler once the handshake is successful\n   *\n   * @param data the data to process\n   * @private\n   */\n  private processData(data: any): void {\n    const message = parseMessageData<SdkMessage>(data);\n\n    let callbacks: FunctionOrPromise[] = [];\n\n    // ignore messages that should not be for us\n    if (message?.version !== this.version || (message as any)?.guid !== this.guid) {\n      return;\n    }\n\n    if (message.action === 'event') {\n      // TODO  Update the receiver on the player's side to find a way to provide error\n      callbacks = this.callbackStore.getCallbacks(`${message.action}:${message.name}`);\n    } else if (message.action === 'get' || message.action === 'set') {\n      const callback = this.callbackStore.shiftCallback(`${message.action}:${message.name}`);\n\n      if (callback) {\n        callbacks.push(callback);\n      }\n    }\n\n    callbacks.forEach((cb) => {\n      if (typeof cb === 'function') {\n        cb((message as SdkGetSetMessage).value);\n      } else {\n        // TODO find a way to use the cb.reject() function;\n        cb.resolve((message as SdkGetSetMessage).value);\n      }\n    });\n  }\n\n  /**\n   * Sends a SET message to the iframe\n   *\n   * @param name the event name to send\n   * @param value the value to send\n   * @private\n   */\n  private set(name: string, value: any): void {\n    if (value === undefined) {\n      throw new TypeError('A value must be set.');\n    }\n\n    this.readyPromise\n      .then(() => {\n        this.postMessage({\n          action: 'set',\n          guid: this.guid,\n          name,\n          value,\n        } as SdkGetSetMessage);\n      });\n  }\n}\n"],"names":["parseMessageData","data","JSON","parse","error","map","Map","getCallbacks","name","get","removeCallback","callback","this","callbacks","delete","index","indexOf","splice","length","set","shiftCallback","shift","storeCallback","push","PlayerSdk","constructor","iframe","callbackStore","guid","messageHandler","originUrl","origin","readyPromise","version","URL","src","crypto","randomUUID","Promise","resolve","event","message","action","processData","window","addEventListener","postMessage","TypeError","then","value","destroy","removeEventListener","disableCaptionTrack","enableCaptionTrack","lang","async","pause","command","play","setCurrentTime","time","Error","setLayout","layout","setPictureInPicturePosition","position","setPlaybackRate","playbackRate","setPrimaryContent","primaryContent","setSideBySideRatio","ratio","setVolume","volume","args","_this","reject","e","messageString","stringify","_extends","_this$iframe$contentW","contentWindow","forEach","cb","undefined"],"mappings":"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"}