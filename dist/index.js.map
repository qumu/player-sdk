{"version":3,"file":"index.js","sources":["../src/lib/functions/functions.ts","../src/lib/callbacks/callbacks.ts","../src/services/player-sdk.service.ts"],"sourcesContent":["/**\n * Parses a message received from postMessage.\n *\n * @param data The data received from postMessage.\n */\nexport function parseMessageData<T>(data: string | T): T {\n  if (typeof data === 'string') {\n    try {\n      // eslint-disable-next-line no-param-reassign\n      data = JSON.parse(data);\n    } catch (error) {\n      return {} as T;\n    }\n  }\n\n  return data as T;\n}\n","export type FunctionOrPromise = Function | { reject: Function; resolve: Function };\n\nexport class CallbackStore {\n  private readonly map = new Map();\n\n  /**\n   * Gets all the callbacks for a specific event name\n   *\n   * @param name the event name we want the callbacks from\n   */\n  getCallbacks(name: string): Function[] | FunctionOrPromise[] {\n    return this.map.get(name) || [];\n  }\n\n  /**\n   * Removes the given callback for the event\n   *\n   * @param name the event name we want the callbacks from\n   * @param callback the callback to remove. If empty, it will remove all callbacks\n   */\n  removeCallback(name: string, callback?: FunctionOrPromise): void {\n    const callbacks = this.map.get(name) || [];\n\n    if (!callbacks) {\n      return;\n    }\n\n    // If no callback is passed, remove all callbacks for the event\n    if (!callback) {\n      this.map.delete(name);\n\n      return;\n    }\n\n    const index = callbacks.indexOf(callback);\n\n    if (index !== -1) {\n      callbacks.splice(index, 1);\n    }\n\n    if (callbacks.length === 0) {\n      this.map.delete(name);\n    } else {\n      this.map.set(name, callbacks);\n    }\n  }\n\n  /**\n   * Removes and return the first callback for the name\n   *\n   * @param name the event name we want the callbacks from\n   */\n  shiftCallback(name: string): FunctionOrPromise | undefined {\n    const callbacks = this.getCallbacks(name);\n\n    if (callbacks.length === 0) {\n      return undefined;\n    }\n\n    const callback = callbacks.shift();\n\n    this.removeCallback(name, callback);\n\n    return callback;\n  }\n\n  /**\n   * Stores the callback for the event\n   *\n   * @param name the event name we want the callbacks from\n   * @param callback the callback to store\n   */\n  storeCallback(name: string, callback: FunctionOrPromise): void {\n    const callbacks = this.map.get(name) || [];\n\n    callbacks.push(callback);\n\n    this.map.set(name, callbacks);\n  }\n}\n","import { parseMessageData } from '../lib/functions/functions';\nimport {\n  SdkCommandMessage,\n  SdkEventMessage,\n  SdkGetSetMessage,\n  SdkHandshakeMessage,\n  SdkMessage,\n} from '../models/internal';\nimport { CallbackStore, FunctionOrPromise } from '../lib/callbacks/callbacks';\nimport { SdkCaptionTrack, SdkLayout, SdkPipPosition, SdkPrimaryContent } from '../models/external';\n\nexport class PlayerSdk {\n  // store used for the callbacks\n  private readonly callbackStore: CallbackStore;\n\n  // Random guid used during Cross window communication\n  // This is useful to prevent communication bleeding between SDKs if the same presentation is used multiple times in the page\n  private readonly guid: string;\n\n  // callback for the message event listener once the handshake is done\n  private messageHandler: ((event: MessageEvent) => void) | undefined;\n\n  // origin url of the iframe's src\n  // we will use it to compare with the event's origin and filter out messages from unknown origins\n  private readonly originUrl: string;\n\n  // origin used to send cross window communication messages\n  // this is useful to target a specific origin and not have to broadcast to everybody\n  private origin = '*';\n\n  private readonly readyPromise: Promise<void>;\n\n  // Cross window communication format version\n  private readonly version = 3;\n\n  constructor(\n    private readonly iframe: HTMLIFrameElement,\n  ) {\n    this.originUrl = new URL(this.iframe.src).origin;\n    this.guid = crypto.randomUUID();\n\n    this.callbackStore = new CallbackStore();\n\n    // create the promise that will be used to verify if the messages can be exchanged with the player\n    this.readyPromise = new Promise((resolve) => {\n      this.messageHandler = (event: MessageEvent) => {\n        // ignore messages coming from another iframe\n        if (event.origin !== this.originUrl) {\n          return;\n        }\n\n        const message = parseMessageData<SdkMessage>(event.data);\n\n        // ignore messages from previous SDKs\n        if (message?.version !== this.version) {\n          return;\n        }\n\n        // ignores handshake from other SDKs\n        if (message?.action === 'handshake' && message?.guid !== this.guid) {\n          return;\n        }\n\n        if (message?.action === 'ready' || message?.action === 'handshake') {\n          // we provide the proper origin\n          // this allows us to send the cross window message to the proper origin and not broadcast to everybody\n          this.origin = event.origin;\n          resolve();\n\n          return;\n        }\n\n        this.processData(message);\n      };\n\n      window.addEventListener('message', this.messageHandler);\n    });\n\n    // we send a request for a handshake\n    // this one is useful in the event when the SDK is initialized after the player\n    this.postMessage({\n      action: 'handshake',\n      guid: this.guid,\n    } as SdkHandshakeMessage);\n  }\n\n  /**\n   * Registers a callback to be run when the event is triggered\n   *\n   * @param name the event name to listen to\n   * @param callback the callback to run when the event is triggered\n   */\n  addEventListener(name: SdkEventMessage['name'], callback: Function): void {\n    if (!name) {\n      throw new TypeError('You must pass an event name.');\n    }\n\n    if (!callback) {\n      throw new TypeError('You must pass a callback function.');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('The callback must be a function.');\n    }\n\n    const callbacks = this.callbackStore.getCallbacks(`event:${name}`);\n\n    // This is the first time we subscribe to this event, we need to tell the Player to start a watcher\n    if (callbacks.length === 0) {\n      this.readyPromise.then(() => {\n        this.postMessage({\n          action: 'event',\n          guid: this.guid,\n          name,\n          value: 'add',\n        } as SdkEventMessage);\n      });\n    }\n\n    this.callbackStore.storeCallback(`event:${name}`, callback);\n  }\n\n  /**\n   * Destroys the whole SDK\n   */\n  destroy(): void {\n    if (this.messageHandler) {\n      window.removeEventListener('message', this.messageHandler);\n    }\n\n    this.postMessage({\n      action: 'command',\n      guid: this.guid,\n      name: 'destroy',\n    } as SdkCommandMessage);\n  }\n\n  /**\n   * Disables any caption track\n   */\n  disableCaptionTrack(): void {\n    this.enableCaptionTrack(null);\n  }\n\n  /**\n   * Sets the current caption track\n   *\n   * @param lang the language of the active track. Use null to disable captions.\n   */\n  enableCaptionTrack(lang: string | null): void {\n    this.set('captionTrack', lang);\n  }\n\n  /**\n   * Gets the available caption tracks\n   */\n  async getCaptionTracks(): Promise<SdkCaptionTrack[]> {\n    return this.get('captionTracks');\n  }\n\n  /**\n   * Gets the chapter\n   */\n  async getChapter(): Promise<any> {\n    return this.get('chapter');\n  }\n\n  /**\n   * Gets the list of chapters for the presentation\n   */\n  async getChapters(): Promise<any[]> {\n    return this.get('chapters');\n  }\n\n  /**\n   * Gets the current caption track\n   */\n  async getCurrentCaptionTrack(): Promise<SdkCaptionTrack | null> {\n    return this.get('captionTrack');\n  }\n\n  /**\n   * Gets the current time in milliseconds\n   */\n  async getCurrentTime(): Promise<number> {\n    return this.get('currentTime');\n  }\n\n  /**\n   * Gets the presentation's duration in milliseconds\n   */\n  async getDuration(): Promise<number> {\n    return this.get('duration');\n  }\n\n  /**\n   * Gets the layout\n   */\n  async getLayout(): Promise<SdkLayout> {\n    return this.get('layout');\n  }\n\n  /**\n   * Gets the presentation's duration in milliseconds\n   */\n  async getLiveEndTime(): Promise<string | null> {\n    return this.get('liveEndTime');\n  }\n\n  /**\n   * Gets the presentation's duration in milliseconds\n   */\n  async getLiveStartTime(): Promise<string | null> {\n    return this.get('liveStartTime');\n  }\n\n  /**\n   * Gets the presentation's live state\n   */\n  async getLiveState(): Promise<string | null> {\n    return this.get('liveState');\n  }\n\n  /**\n   * Gets the position of the PiP box\n   */\n  async getPictureInPicturePosition(): Promise<number> {\n    return this.get('pipPosition');\n  }\n\n  /**\n   * Gets the current playback rate\n   */\n  async getPlaybackRate(): Promise<number> {\n    return this.get('playbackRate');\n  }\n\n  /**\n   * Gets the list of playback rates\n   */\n  async getPlaybackRates(): Promise<number[]> {\n    return this.get('playbackRates');\n  }\n\n  /**\n   * Gets the presentation\n   */\n  async getPresentation(): Promise<any> {\n    return this.get('presentation');\n  }\n\n  /**\n   * Gets the primary content\n   */\n  async getPrimaryContent(): Promise<SdkPrimaryContent> {\n    return this.get('primaryContent');\n  }\n\n  /**\n   * Gets the side by side ratio between 50% and 80%\n   */\n  async getSideBySideRatio(): Promise<number> {\n    return this.get('sideBySideRatio');\n  }\n\n  /**\n   * Gets the player's volume between 0 and 100\n   */\n  async getVolume(): Promise<number> {\n    return this.get('volume');\n  }\n\n  /**\n   * Checks whether the player is paused or playing\n   */\n  async isPaused(): Promise<boolean> {\n    return this.get('paused');\n  }\n\n  /**\n   * Pauses the player\n   */\n  pause(): void {\n    this.command('pause');\n  }\n\n  /**\n   * Plays the player\n   */\n  play(): void {\n    this.command('play');\n  }\n\n  /**\n   * Stops listening to a player event\n   *\n   * @param name the event name to listen to\n   * @param callback the callback to remove. If no callback is provided, all callbacks will be removed for the event name\n   */\n  removeEventListener(name: string, callback?: Function): void {\n    if (!name) {\n      throw new TypeError('You must pass an event name.');\n    }\n\n    this.callbackStore.removeCallback(`event:${name}`, callback);\n\n    const callbacks = this.callbackStore.getCallbacks(`event:${name}`);\n\n    // Remove the watcher on the player's side if there are no subscribers for this event\n    if (callbacks.length === 0) {\n      this.postMessage({\n        action: 'event',\n        guid: this.guid,\n        name,\n        value: 'remove',\n      } as SdkEventMessage);\n    }\n  }\n\n  /**\n   * Sets the current time in the player\n   *\n   * @param time the new current time in milliseconds\n   */\n  setCurrentTime(time: number): void {\n    if (time < 0) {\n      throw new Error('The current time must be superior or equal to 0');\n    }\n\n    this.set('currentTime', time);\n  }\n\n  /**\n   * Sets the layout\n   *\n   * @param layout the new layout, either 'pip' or 'sbs'\n   */\n  setLayout(layout: SdkLayout): void {\n    this.set('layout', layout);\n  }\n\n  /**\n   * Sets the position of the PiP box\n   *\n   * @param position the PiP position\n   */\n  setPictureInPicturePosition(position: SdkPipPosition): void {\n    this.set('pipPosition', position);\n  }\n\n  /**\n   * Sets the playback rate in the player. The value must be between 0 and 2.\n   *\n   * @param playbackRate the new playback rate\n   */\n  setPlaybackRate(playbackRate: number): void {\n    if (playbackRate < 0) {\n      throw new Error('The playback rate must be superior or equal to 0');\n    }\n\n    if (playbackRate > 2) {\n      throw new Error('The playback rate must be inferior or equal to 2');\n    }\n\n    this.set('playbackRate', playbackRate);\n  }\n\n  /**\n   * Sets the primary content\n   *\n   * @param primaryContent the primary content\n   */\n  setPrimaryContent(primaryContent: SdkPrimaryContent): void {\n    this.set('primaryContent', primaryContent);\n  }\n\n  /**\n   * Sets the ratio for the Side by Side mode\n   *\n   * @param ratio the new ratio. The range is 50-80.\n   */\n  setSideBySideRatio(ratio: number): void {\n    if (ratio < 50 || ratio > 80) {\n      throw new Error('The ratio must be between 50 and 80');\n    }\n\n    this.set('sideBySideRatio', ratio);\n  }\n\n  /**\n   * Sets the volume in the player\n   *\n   * @param volume the new volume. The range is 0-100.\n   */\n  setVolume(volume: number): void {\n    if (volume < 0 || volume > 100) {\n      throw new Error('The volume must be between 0 and 100');\n    }\n\n    this.set('volume', volume);\n  }\n\n  /**\n   * Sends a COMMAND message to the iframe\n   *\n   * @param name the event name to send\n   * @param args optional arguments to send\n   * @private\n   */\n  private command(name: SdkCommandMessage['name'], args?: any): void {\n    const message: Omit<SdkCommandMessage, 'version'> = {\n      action: 'command',\n      guid: this.guid,\n      name,\n    };\n\n    if (args) {\n      message.value = args;\n    }\n\n    this.postMessage(message);\n  }\n\n  /**\n   * Sends a GET message to the iframe\n   *\n   * @param name the event name to send\n   * @private\n   */\n  private get<T>(name: SdkGetSetMessage['name']): Promise<T> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await this.readyPromise;\n\n        this.callbackStore.storeCallback(`get:${name}`, {\n          reject,\n          resolve,\n        });\n\n        this.postMessage({\n          action: 'get',\n          guid: this.guid,\n          name,\n        } as SdkGetSetMessage);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Sends a message to the iframe\n   *\n   * @param message the message to send\n   * @private\n   */\n  private postMessage(message: Omit<SdkMessage, 'version'>): void {\n    const messageString = JSON.stringify({\n      ...message,\n      version: this.version,\n    });\n\n    this.iframe.contentWindow?.postMessage(messageString, this.origin);\n  }\n\n  /**\n   * Processes the data from the message handler once the handshake is successful\n   *\n   * @param data the data to process\n   * @private\n   */\n  private processData(data: any): void {\n    const message = parseMessageData<SdkMessage>(data);\n\n    let callbacks: FunctionOrPromise[] = [];\n\n    // ignore messages that should not be for us\n    if (message?.version !== this.version || (message as any)?.guid !== this.guid) {\n      return;\n    }\n\n    if (message.action === 'event') {\n      // TODO  Update the receiver on the player's side to find a way to provide error\n      callbacks = this.callbackStore.getCallbacks(`${message.action}:${message.name}`);\n    } else if (message.action === 'get' || message.action === 'set') {\n      const callback = this.callbackStore.shiftCallback(`${message.action}:${message.name}`);\n\n      if (callback) {\n        callbacks.push(callback);\n      }\n    }\n\n    callbacks.forEach((cb) => {\n      if (typeof cb === 'function') {\n        cb((message as SdkGetSetMessage).value);\n      } else {\n        // TODO find a way to use the cb.reject() function;\n        cb.resolve((message as SdkGetSetMessage).value);\n      }\n    });\n  }\n\n  /**\n   * Sends a SET message to the iframe\n   *\n   * @param name the event name to send\n   * @param value the value to send\n   * @private\n   */\n  private set(name: string, value: any): void {\n    if (value === undefined) {\n      throw new TypeError('A value must be set.');\n    }\n\n    this.readyPromise\n      .then(() => {\n        this.postMessage({\n          action: 'set',\n          guid: this.guid,\n          name,\n          value,\n        } as SdkGetSetMessage);\n      });\n  }\n}\n"],"names":["parseMessageData","data","JSON","parse","error","CallbackStore","map","Map","_proto","prototype","getCallbacks","name","get","removeCallback","callback","callbacks","this","index","indexOf","splice","length","set","shiftCallback","shift","storeCallback","push","PlayerSdk","iframe","callbackStore","guid","messageHandler","originUrl","origin","readyPromise","version","URL","src","crypto","randomUUID","resolve","_this","event","message","action","processData","window","addEventListener","postMessage","_this2","TypeError","then","value","destroy","removeEventListener","disableCaptionTrack","enableCaptionTrack","lang","getCaptionTracks","Promise","getChapter","e","reject","getChapters","getCurrentCaptionTrack","getCurrentTime","getDuration","getLayout","getLiveEndTime","getLiveStartTime","getLiveState","getPictureInPicturePosition","getPlaybackRate","getPlaybackRates","getPresentation","getPrimaryContent","getSideBySideRatio","getVolume","isPaused","pause","command","play","setCurrentTime","time","Error","setLayout","layout","setPictureInPicturePosition","position","setPlaybackRate","playbackRate","setPrimaryContent","primaryContent","setSideBySideRatio","ratio","setVolume","volume","args","_this39","_temp2","_this$iframe$contentW","messageString","stringify","contentWindow","forEach","cb","_this40","undefined"],"mappings":"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"}